/* 
My broken solution 

// The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

// Let us list the factors of the first seven triangle numbers:

// 1: 1
// 3: 1,3
// 6: 1,2,3,6
// 10: 1,2,5,10
// 15: 1,3,5,15
// 21: 1,3,7,21
// 28: 1,2,4,7,14,28
// We can see that 28 is the first triangle number to have over five divisors.

// What is the value of the first triangle number to have over five hundred divisors?

const findTriangle = (num) => {
  var abs = Math.abs(num);
  return ((abs / 2) * (abs + 1)) * (abs / num) || 0;
}

// const findDivisors = (num) => {
//   let myDivisors = [num];
//   for (let i = 1; i <= Math.floor(num / 2); i++) {
//     if (num % i === 0) {
//       myDivisors.push(i)
//     }
//   }
//   return myDivisors;
// }

function findDivisors(n){

    var numDivisors = 1;
    var factor = 2; // Candidate for prime factor of `n`

    // If `n` is not a prime number then it must have one factor
    // which is <= `sqrt(n)`, so we try these first:
    while (factor * factor <= n) {
        if (n % factor === 0) {
            // `factor` is a prime factor of `n`, determine the exponent:
            var exponent = 0;
            do {
                n /= factor;
                exponent++;
            } while (n % factor === 0)
            // `factor^exponent` is one term in the prime factorization of n,
            // this contributes as factor `exponent + 1`:
            numDivisors *= exponent + 1;
            // Next possible prime factor:
            factor = factor == 2 ? 3 : factor + 2
        }
    }

    // Now `n` is either 1 or a prime number. In the latter case,
    // it contributes a factor 2:
    if (n > 1) {
        numDivisors *= 2;
    }

    return numDivisors;
}

const firstTriOverX = (num) => {
  let result;
  let i = 1;
  while (!result) {
    if (findDivisors(findTriangle(i)).length > num) {
      result = findTriangle(i)
    }
    i++;
  }
  return result;
}

console.log(firstTriOverX(500))
*/
 
const GetTriangleNumber = index => ( (index * (index + 1)) / 2)

const GetDivisors = dividend => {
    let divisors = [] //dividend and 1 always divide
    for(let i = 1; i <= Math.sqrt(dividend); i++) {
        if(dividend % i === 0) {
            divisors.push(i)
            divisors.push(dividend/i)
        }
    }
    divisors.sort((a,b) => a-b)
    return divisors
}

const GetFirstTriangleNumberWithOver = divisorCount => {
    let candidate = 1
    let triangle = GetTriangleNumber(candidate)
    while(GetDivisors(triangle).length < divisorCount) {
        candidate ++
        triangle = GetTriangleNumber(candidate)
    }
    return triangle
}

console.log(GetFirstTriangleNumberWithOver(500))